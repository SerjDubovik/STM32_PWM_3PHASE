#include "stm32f10x.h"
#include "modbus.h"
#include "GPIO.h"
#include "pwm.h"






unsigned short	array_mb[100]			= {};				// массив для хранения принятых/переданных слов




int main(void)
{


	init_GPIO();
    init_modbus();


    RCC->APB2ENR|= RCC_APB2ENR_TIM1EN;

    TIM1->CCMR1=TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1PE;

    TIM1->CCER=TIM_CCER_CC1E | TIM_CCER_CC1NE;				// разрешение комплиментарного режима
    TIM1->CCER=TIM_CCER_CC2E | TIM_CCER_CC2NE;
    TIM1->CCER=TIM_CCER_CC3E | TIM_CCER_CC3NE;

    TIM1->BDTR=TIM_BDTR_MOE | DEADTIME;
    TIM1->ARR=period;										// период
    TIM1->CR1=TIM_CR1_ARPE;
    TIM1->CR1|=TIM_CR1_CEN;
    TIM1->EGR=TIM_EGR_UG;

    TIM1->CCR1=PWM_1;										// мгновенные значения шима
    TIM1->CCR2=PWM_2;
    TIM1->CCR3=PWM_3;





	for(;;)
	{

		if(step_PWM_1 <= 180)
		{
			PWM_1 = (factor_voltage * (sin_mass[step_PWM_1] * half_period)) + half_period;
		}

		if(step_PWM_1 > 180)
		{
			PWM_1 = half_period - (factor_voltage * (sin_mass[step_PWM_1 - 180] * half_period));
		}

		if(step_PWM_1 >= 360)
		{
			step_PWM_1 = 0;
		}
		else
		{
			step_PWM_1++;
		}
/////////

		if(step_PWM_2 <= 180)
		{
			PWM_2 = (factor_voltage * (sin_mass[step_PWM_2] * half_period)) + half_period;
		}

		if(step_PWM_2 > 180)
		{
			PWM_2 = half_period - (factor_voltage * (sin_mass[step_PWM_2 - 180] * half_period));
		}

		if(step_PWM_2 >= 360)
		{
			step_PWM_2 = 0;
		}
		else
		{
			step_PWM_2++;
		}
/////////
		if(step_PWM_3 <= 180)
		{
			PWM_3 = (factor_voltage * (sin_mass[step_PWM_3] * half_period)) + half_period;
		}

		if(step_PWM_3 > 180)
		{
			PWM_3 = half_period - (factor_voltage * (sin_mass[step_PWM_3 - 180] * half_period));
		}

		if(step_PWM_3 >= 360)
		{
			step_PWM_3 = 0;
		}
		else
		{
			step_PWM_3++;
		}
/////////


/*
		array_mb[8]++;

		Modbus_slave();
*/
	} // скобка бесконечного цикла
} // скобка мейна
